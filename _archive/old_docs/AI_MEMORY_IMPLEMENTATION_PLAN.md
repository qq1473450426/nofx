# AIæŒä¹…è®°å¿†ç³»ç»Ÿå®æ–½æ–¹æ¡ˆï¼ˆæ•´åˆç‰ˆï¼‰

## ğŸ“‹ æ–¹æ¡ˆæ¦‚è¿°

åŸºäºåŸå§‹è®¾è®¡æ–¹æ¡ˆå’Œä¼˜åŒ–å»ºè®®ï¼Œåˆ¶å®š3ä¸ªSprintçš„æ¸è¿›å¼å®æ–½è®¡åˆ’ã€‚

---

## ğŸ¯ æ ¸å¿ƒè®¾è®¡å†³ç­–

### 1. è®°å¿†æ¶æ„ï¼šä¸‰å±‚ç»“æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Working Memoryï¼ˆå·¥ä½œè®°å¿†ï¼‰                            â”‚
â”‚ - æœ€è¿‘10ä¸ªå†³ç­–å‘¨æœŸ                                    â”‚
â”‚ - å½“å‰æŒä»“çŠ¶æ€                                        â”‚
â”‚ - ç«‹å³ä¸Šä¸‹æ–‡                                          â”‚
â”‚ ç”¨é€”ï¼šé¿å…"10åˆ†é’Ÿå‰è¯´è¿‡ä»€ä¹ˆ"çš„å¤±å¿†                     â”‚
â”‚ æ›´æ–°ï¼šæ¯ä¸ªå‘¨æœŸ                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Episodic Memoryï¼ˆæƒ…æ™¯è®°å¿†ï¼‰                          â”‚
â”‚ - æœ€è¿‘100ç¬”å®Œæ•´äº¤æ˜“è®°å½•                               â”‚
â”‚ - ç‰¹æ®Šå¸‚åœºäº‹ä»¶ï¼ˆflash crashç­‰ï¼‰                       â”‚
â”‚ - å†³ç­–-ç»“æœçš„å…·ä½“æ¡ˆä¾‹                                 â”‚
â”‚ ç”¨é€”ï¼šæ£€ç´¢ç›¸ä¼¼å†å²åœºæ™¯                                â”‚
â”‚ æ›´æ–°ï¼šæ¯ç¬”äº¤æ˜“                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Semantic Memoryï¼ˆè¯­ä¹‰è®°å¿†ï¼‰                          â”‚
â”‚ - AIæç‚¼çš„ç»éªŒè§„å¾‹                                    â”‚
â”‚ - å·²éªŒè¯çš„äº¤æ˜“åŸåˆ™                                    â”‚
â”‚ - Regime-Stageç­–ç•¥çŸ©é˜µ                               â”‚
â”‚ ç”¨é€”ï¼šå½¢æˆç¨³å®šçš„äº¤æ˜“äººæ ¼                              â”‚
â”‚ æ›´æ–°ï¼šæ¯50ç¬”äº¤æ˜“ï¼ˆæˆ–æ€§èƒ½çªå˜æ—¶ï¼‰                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. ç§å­çŸ¥è¯†ï¼šç¡¬çº¦æŸ + è½¯æŒ‡å¯¼

```json
{
  "seed_knowledge": {
    "hard_constraints": [
      "å•ç¬”æœ€å¤§äºæŸä¸è¶…è¿‡5%ï¼ˆç”±ç°æœ‰constraintsç³»ç»Ÿä¿è¯ï¼‰",
      "æ—¥å†…æœ€å¤§å›æ’¤ä¸è¶…è¿‡10%"
    ],
    "soft_guidelines": [
      {
        "id": "sg_001",
        "rule": "æŒä»“æ–¹å‘ä¸é¢„æµ‹æ–¹å‘å†²çªæ—¶ï¼Œä¼˜å…ˆä¿æŠ¤åˆ©æ¶¦",
        "confidence": 0.5,
        "status": "unverified",
        "reason": "é¿å…æ˜æ˜¾çš„è‡ªç›¸çŸ›ç›¾ï¼ˆå¦‚cycle #1132çš„SHORTæŒä»“+UPé¢„æµ‹ï¼‰"
      },
      {
        "id": "sg_002",
        "rule": "è¿ç»­2æ¬¡æ­¢æŸåï¼Œé™ä½ä»“ä½è‡³30%",
        "confidence": 0.6,
        "status": "unverified",
        "reason": "é£é™©æ§åˆ¶å¸¸è¯†"
      },
      {
        "id": "sg_003",
        "rule": "distributioné˜¶æ®µè°¨æ…åšå¤šï¼ˆé™¤éæœ‰æ˜ç¡®åè½¬ä¿¡å·ï¼‰",
        "confidence": 0.5,
        "status": "unverified",
        "reason": "è¶‹åŠ¿äº¤æ˜“åŸºæœ¬åŸåˆ™"
      }
    ]
  }
}
```

**éªŒè¯æœºåˆ¶**ï¼š
- æ¯æ¬¡åº”ç”¨soft_guidelineæ—¶ï¼Œè®°å½•ç»“æœ
- 100ç¬”äº¤æ˜“åï¼ŒAIåˆ†æï¼š"è¿™æ¡guidelineæœ‰æ•ˆå—ï¼Ÿ"
- æœ‰æ•ˆ â†’ æå‡confidenceï¼Œè½¬å…¥semantic memory
- æ— æ•ˆ â†’ é™ä½confidenceæˆ–åˆ é™¤

### 3. Regime Stageåˆ¤æ–­ï¼š70%æ—¶é—´ + 30%ç‰¹å¾

```go
// ç»„åˆåˆ¤æ–­æ–¹æ³•
func determineRegimeStage(
    regime string,
    regimeDuration time.Duration,
    marketData *market.Data,
) string {
    // 70%æƒé‡ï¼šåŸºäºæ—¶é—´çš„ç®€å•åˆ¤æ–­
    timeScore := calculateTimeBasedStage(regime, regimeDuration)

    // 30%æƒé‡ï¼šåŸºäºå¸‚åœºç‰¹å¾
    featureScore := calculateFeatureBasedStage(regime, marketData)

    finalScore := timeScore * 0.7 + featureScore * 0.3

    if finalScore < 0.33 {
        return "early"
    } else if finalScore < 0.67 {
        return "mid"
    }
    return "late"
}

// æ—¶é—´åŸºçº¿ï¼ˆå¯è¢«AIå­¦ä¹ åè°ƒæ•´ï¼‰
var regimeTimelines = map[string]struct{
    EarlyMin, MidMin, LateMin time.Duration
}{
    "accumulation": {0, 20 * time.Minute, 40 * time.Minute},
    "markup":       {0, 15 * time.Minute, 30 * time.Minute},
    "distribution": {0, 20 * time.Minute, 40 * time.Minute},
    "markdown":     {0, 10 * time.Minute, 25 * time.Minute},
}

// ç‰¹å¾è¯„åˆ†ï¼ˆä»·æ ¼åŠ¨é‡ã€æˆäº¤é‡ã€æ³¢åŠ¨ç‡ï¼‰
func calculateFeatureBasedStage(regime string, data *market.Data) float64 {
    score := 0.0

    // ç‰¹å¾1ï¼šä»·æ ¼åŠ¨é‡å¼ºåº¦ï¼ˆMACDçš„å˜åŒ–ç‡ï¼‰
    if len(data.LongerTermContext.MACDValues) >= 3 {
        macdSlope := calculateSlope(data.LongerTermContext.MACDValues[-3:])
        if regime == "accumulation" || regime == "markup" {
            // ä¸Šå‡è¶‹åŠ¿ï¼šåŠ¨é‡å¢å¼º = è¿›å…¥mid/late
            if macdSlope > 0 {
                score += 0.3
            }
        }
    }

    // ç‰¹å¾2ï¼šæˆäº¤é‡è¶‹åŠ¿
    volRatio := data.LongerTermContext.CurrentVolume / data.LongerTermContext.AverageVolume
    if volRatio > 1.5 {
        // æˆäº¤é‡æ”¾å¤§ = å¯èƒ½è¿›å…¥mid stage
        score += 0.4
    } else if volRatio < 0.8 {
        // æˆäº¤é‡èç¼© = å¯èƒ½è¿›å…¥late stage
        score -= 0.2
    }

    // ç‰¹å¾3ï¼šæ³¢åŠ¨ç‡å˜åŒ–
    atrRatio := data.LongerTermContext.ATR3 / data.LongerTermContext.ATR14
    if atrRatio > 1.2 {
        // çŸ­æœŸæ³¢åŠ¨ç‡å¢åŠ  = å¯èƒ½è¿›å…¥early/mid
        score += 0.3
    }

    // å½’ä¸€åŒ–åˆ°[0, 1]
    return clamp(score, 0.0, 1.0)
}
```

### 4. æ›´æ–°ç­–ç•¥ï¼šè‡ªé€‚åº”è§¦å‘

```go
type UpdateTrigger struct {
    LastUpdateAt  time.Time
    LastTotalTrades int
}

func (t *UpdateTrigger) ShouldUpdate(memory *TraderMemory) (bool, string) {
    // è§„åˆ™1ï¼šåŸºç¡€é¢‘ç‡ï¼ˆæ¯50ç¬”ï¼‰
    if memory.TotalTrades - t.LastTotalTrades >= 50 {
        return true, "scheduled_update"
    }

    // è§„åˆ™2ï¼šæ€§èƒ½çªå˜ï¼ˆæœ€è¿‘20ç¬” vs å†å²ï¼‰
    if memory.TotalTrades >= 20 {
        recentWinRate := calculateWinRate(memory.GetRecentTrades(20))
        historicalWinRate := memory.AIInsights.OverallWinRate

        if math.Abs(recentWinRate - historicalWinRate) > 0.2 {
            return true, fmt.Sprintf("performance_anomaly: recent=%.1f%% vs historical=%.1f%%",
                recentWinRate*100, historicalWinRate*100)
        }
    }

    // è§„åˆ™3ï¼šæ–°æ¨¡å¼æ£€æµ‹ï¼ˆè¿ç»­5æ¬¡ç‰¹å®šä¿¡å·ç»„åˆï¼‰
    if hasNewPattern(memory.GetRecentTrades(20)) {
        return true, "new_pattern_detected"
    }

    // è§„åˆ™4ï¼šå¸‚åœºå¼‚å¸¸äº‹ä»¶
    if hasMarketAnomaly(memory.GetRecentTrades(5)) {
        return true, "market_anomaly"
    }

    return false, ""
}

// æ–°æ¨¡å¼æ£€æµ‹ï¼šå‘ç°ä¹‹å‰æœªè§è¿‡çš„ä¿¡å·ç»„åˆ
func hasNewPattern(trades []TradeEntry) bool {
    // æ£€æŸ¥æ˜¯å¦æœ‰è¿ç»­5æ¬¡ä½¿ç”¨ç›¸åŒä¿¡å·ç»„åˆ
    signalGroups := make(map[string]int)

    for _, trade := range trades {
        key := strings.Join(trade.Signals, "+")
        signalGroups[key]++

        // å¦‚æœæŸä¸ªç»„åˆå‡ºç°5æ¬¡ä»¥ä¸Šï¼Œä¸”ä¹‹å‰æ€»ä½“<10æ¬¡
        if signalGroups[key] >= 5 {
            // TODO: æŸ¥è¯¢å†å²ï¼Œå¦‚æœæ€»æ¬¡æ•°<10æ¬¡ï¼Œè®¤ä¸ºæ˜¯æ–°æ¨¡å¼
            return true
        }
    }

    return false
}

// å¸‚åœºå¼‚å¸¸æ£€æµ‹
func hasMarketAnomaly(trades []TradeEntry) bool {
    // æ£€æµ‹extreme eventsï¼š
    // - å•æ¬¡äºæŸ > 3%
    // - å•æ—¥å›æ’¤ > 8%
    // - ä»·æ ¼å•å°æ—¶å˜åŒ– > 5%

    for _, trade := range trades {
        if trade.ReturnPct < -3.0 {
            return true
        }
    }

    return false
}
```

---

## ğŸš€ å®æ–½è®¡åˆ’ï¼š3ä¸ªSprint

### Sprint 1ï¼ˆç¬¬1å‘¨ï¼‰ï¼šç«‹å³è§æ•ˆçš„MVP

**ç›®æ ‡**ï¼šè§£å†³"å¤±å¿†ç—‡"ï¼ŒAIèƒ½è®°ä½æœ€è¿‘çš„å†³ç­–

#### 1.1 æ•°æ®ç»“æ„ï¼ˆç®€åŒ–ç‰ˆï¼‰

```go
// memory/simple.go
package memory

import (
    "encoding/json"
    "os"
    "sync"
    "time"
)

type SimpleMemory struct {
    Version      string        `json:"version"`
    TraderID     string        `json:"trader_id"`
    CreatedAt    time.Time     `json:"created_at"`
    TotalTrades  int           `json:"total_trades"`

    // Working Memory: æœ€è¿‘20ç¬”äº¤æ˜“
    RecentTrades []TradeEntry  `json:"recent_trades"`

    // Seed Knowledge: åˆå§‹æŒ‡å¯¼åŸåˆ™
    SeedKnowledge *SeedKnowledge `json:"seed_knowledge"`

    mu sync.RWMutex
}

type TradeEntry struct {
    TradeID   int       `json:"trade_id"`
    Cycle     int       `json:"cycle"`
    Timestamp time.Time `json:"timestamp"`

    // å¸‚åœºç¯å¢ƒ
    MarketRegime  string  `json:"market_regime"`  // accumulation/markup/...
    RegimeStage   string  `json:"regime_stage"`   // early/mid/late

    // å†³ç­–ä¿¡æ¯
    Action    string   `json:"action"`     // open/close/hold
    Symbol    string   `json:"symbol"`
    Side      string   `json:"side"`       // long/short
    Signals   []string `json:"signals"`    // ["MACDé‡‘å‰", "RSIè¶…å–"]
    Reasoning string   `json:"reasoning"`

    // æŒä»“ä¿¡æ¯
    EntryPrice  float64 `json:"entry_price,omitempty"`
    ExitPrice   float64 `json:"exit_price,omitempty"`
    PositionPct float64 `json:"position_pct"`

    // ç»“æœ
    HoldMinutes int     `json:"hold_minutes,omitempty"`
    ReturnPct   float64 `json:"return_pct"`
    Result      string  `json:"result"`  // win/loss/break_even
}

type SeedKnowledge struct {
    HardConstraints []string          `json:"hard_constraints"`
    SoftGuidelines  []SoftGuideline   `json:"soft_guidelines"`
}

type SoftGuideline struct {
    ID         string  `json:"id"`
    Rule       string  `json:"rule"`
    Confidence float64 `json:"confidence"`
    Status     string  `json:"status"`  // unverified/validated/rejected
    UsageCount int     `json:"usage_count"`
    SuccessCount int   `json:"success_count"`
}
```

#### 1.2 Memory Managerï¼ˆåŸºç¡€åŠŸèƒ½ï¼‰

```go
// memory/manager.go
package memory

import (
    "encoding/json"
    "fmt"
    "os"
    "time"
)

type Manager struct {
    filepath string
    memory   *SimpleMemory
}

func NewManager(traderID string) (*Manager, error) {
    filepath := fmt.Sprintf("trader_memory/%s.json", traderID)

    m := &Manager{
        filepath: filepath,
    }

    // å°è¯•åŠ è½½ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
    if err := m.Load(); err != nil {
        if os.IsNotExist(err) {
            m.memory = initializeMemory(traderID)
            if err := m.Save(); err != nil {
                return nil, err
            }
        } else {
            return nil, err
        }
    }

    return m, nil
}

func initializeMemory(traderID string) *SimpleMemory {
    return &SimpleMemory{
        Version:      "1.0",
        TraderID:     traderID,
        CreatedAt:    time.Now(),
        TotalTrades:  0,
        RecentTrades: make([]TradeEntry, 0, 20),
        SeedKnowledge: &SeedKnowledge{
            HardConstraints: []string{
                "å•ç¬”æœ€å¤§äºæŸä¸è¶…è¿‡5%",
                "æ—¥å†…æœ€å¤§å›æ’¤ä¸è¶…è¿‡10%",
            },
            SoftGuidelines: []SoftGuideline{
                {
                    ID:         "sg_001",
                    Rule:       "æŒä»“æ–¹å‘ä¸é¢„æµ‹æ–¹å‘å†²çªæ—¶ï¼Œä¼˜å…ˆä¿æŠ¤åˆ©æ¶¦",
                    Confidence: 0.5,
                    Status:     "unverified",
                },
                {
                    ID:         "sg_002",
                    Rule:       "è¿ç»­2æ¬¡æ­¢æŸåï¼Œé™ä½ä»“ä½è‡³30%",
                    Confidence: 0.6,
                    Status:     "unverified",
                },
            },
        },
    }
}

func (m *Manager) Load() error {
    data, err := os.ReadFile(m.filepath)
    if err != nil {
        return err
    }

    m.memory = &SimpleMemory{}
    return json.Unmarshal(data, m.memory)
}

func (m *Manager) Save() error {
    data, err := json.MarshalIndent(m.memory, "", "  ")
    if err != nil {
        return err
    }

    return os.WriteFile(m.filepath, data, 0644)
}

// AddTrade æ·»åŠ äº¤æ˜“è®°å½•
func (m *Manager) AddTrade(entry TradeEntry) error {
    m.memory.mu.Lock()
    defer m.memory.mu.Unlock()

    entry.TradeID = m.memory.TotalTrades + 1

    // åªä¿ç•™æœ€è¿‘20ç¬”
    m.memory.RecentTrades = append(m.memory.RecentTrades, entry)
    if len(m.memory.RecentTrades) > 20 {
        m.memory.RecentTrades = m.memory.RecentTrades[1:]
    }

    m.memory.TotalTrades++

    return m.Save()
}

// GetContextPrompt ç”Ÿæˆä¸Šä¸‹æ–‡æç¤ºï¼ˆä¾›AIå†³ç­–æ—¶ä½¿ç”¨ï¼‰
func (m *Manager) GetContextPrompt() string {
    m.memory.mu.RLock()
    defer m.memory.mu.RUnlock()

    if m.memory.TotalTrades == 0 {
        return "è¿™æ˜¯ä½ çš„ç¬¬ä¸€æ¬¡äº¤æ˜“ï¼Œä½ è¿˜æ²¡æœ‰ä»»ä½•å†å²è®°å½•ã€‚"
    }

    // æœ€è¿‘3æ¬¡å†³ç­–çš„æ‘˜è¦
    recent := m.memory.RecentTrades
    n := len(recent)

    prompt := fmt.Sprintf("## ğŸ“ ä½ çš„æœ€è¿‘å†³ç­–ï¼ˆæ€»å…±%dç¬”äº¤æ˜“ï¼‰\n\n", m.memory.TotalTrades)

    // æ˜¾ç¤ºæœ€è¿‘3ç¬”
    start := n - 3
    if start < 0 {
        start = 0
    }

    for i := start; i < n; i++ {
        trade := recent[i]
        timeSince := time.Since(trade.Timestamp)

        prompt += fmt.Sprintf("**å‘¨æœŸ#%d** (%så‰):\n", trade.Cycle, formatDuration(timeSince))
        prompt += fmt.Sprintf("  å†³ç­–: %s %s %s\n", trade.Action, trade.Symbol, trade.Side)
        prompt += fmt.Sprintf("  æ¨ç†: %s\n", trade.Reasoning)

        if trade.Result != "" {
            emoji := "âœ…"
            if trade.Result == "loss" {
                emoji = "âŒ"
            }
            prompt += fmt.Sprintf("  ç»“æœ: %s %.2f%%\n", emoji, trade.ReturnPct)
        }
        prompt += "\n"
    }

    // æ·»åŠ soft guidelines
    prompt += "## ğŸ’¡ ä½ çš„äº¤æ˜“åŸåˆ™ï¼ˆå¾…éªŒè¯ï¼‰\n\n"
    for _, guideline := range m.memory.SeedKnowledge.SoftGuidelines {
        status := "ğŸ”„"
        if guideline.Status == "validated" {
            status = "âœ…"
        } else if guideline.Status == "rejected" {
            status = "âŒ"
        }

        winRate := 0.0
        if guideline.UsageCount > 0 {
            winRate = float64(guideline.SuccessCount) / float64(guideline.UsageCount) * 100
        }

        prompt += fmt.Sprintf("%s %s (ä½¿ç”¨%dæ¬¡ï¼ŒæˆåŠŸç‡%.0f%%)\n",
            status, guideline.Rule, guideline.UsageCount, winRate)
    }

    return prompt
}

func formatDuration(d time.Duration) string {
    if d < time.Minute {
        return "åˆšæ‰"
    } else if d < time.Hour {
        return fmt.Sprintf("%dåˆ†é’Ÿ", int(d.Minutes()))
    } else {
        return fmt.Sprintf("%då°æ—¶", int(d.Hours()))
    }
}
```

#### 1.3 é›†æˆåˆ°å†³ç­–æµç¨‹

```go
// decision/engine.go

func (e *Engine) Decide() (*Decision, error) {
    // 1. åŠ è½½è®°å¿†
    contextPrompt := e.memoryManager.GetContextPrompt()

    // 2. è·å–å¸‚åœºæ•°æ®
    marketData := e.getMarketData()

    // 3. æ„å»ºå®Œæ•´promptï¼ˆåŒ…å«è®°å¿†ï¼‰
    systemPrompt := buildSystemPrompt()
    userPrompt := fmt.Sprintf(`
%s

## ğŸ“Š å½“å‰å¸‚åœºçŠ¶æ€
%s

## ğŸ¤” ä½ çš„ä»»åŠ¡
åŸºäºä½ çš„å†å²ç»éªŒå’Œå½“å‰æ•°æ®ï¼Œå†³å®šæ˜¯å¦å…¥åœº/æŒæœ‰/å¹³ä»“ã€‚
ç‰¹åˆ«æ³¨æ„ï¼š
1. ä½ ä¹‹å‰è¯´è¿‡ä»€ä¹ˆï¼Ÿç°åœ¨çš„åˆ¤æ–­æ˜¯å¦ä¸ä¹‹å‰ä¸€è‡´ï¼Ÿ
2. æ˜¯å¦è§¦çŠ¯äº†ä½ çš„äº¤æ˜“åŸåˆ™ï¼Ÿ
3. å¦‚æœæ–¹å‘æ”¹å˜ï¼Œè¦è¯´æ˜åŸå› 
`, contextPrompt, formatMarketData(marketData))

    // 4. è°ƒç”¨AI
    response := e.mcpClient.Call(systemPrompt, userPrompt)

    // 5. æ‰§è¡Œå†³ç­– + è®°å½•åˆ°è®°å¿†
    decision := parseDecision(response)
    e.executeDecision(decision)

    // 6. è®°å½•äº¤æ˜“
    if decision.Action == "open" || decision.Action == "close" {
        entry := TradeEntry{
            Cycle:        e.currentCycle,
            Timestamp:    time.Now(),
            MarketRegime: marketData.Intelligence.MarketPhase,
            RegimeStage:  determineRegimeStage(marketData),
            Action:       decision.Action,
            Symbol:       decision.Symbol,
            Reasoning:    decision.Reasoning,
            // ... å…¶ä»–å­—æ®µ
        }

        e.memoryManager.AddTrade(entry)
    }

    return decision, nil
}
```

#### 1.4 Sprint 1æ•ˆæœéªŒè¯

**é¢„æœŸæ•ˆæœ**ï¼š
- âœ… AIèƒ½çœ‹åˆ°æœ€è¿‘3æ¬¡å†³ç­–
- âœ… èƒ½é¿å…æ˜æ˜¾çš„è‡ªç›¸çŸ›ç›¾ï¼ˆå¦‚cycle #1132çš„é—®é¢˜ï¼‰
- âœ… èƒ½åº”ç”¨soft guidelinesï¼ˆå¦‚"æŒä»“-é¢„æµ‹å†²çªæ—¶å¹³ä»“"ï¼‰
- âœ… äº¤æ˜“è®°å½•æŒä¹…åŒ–ä¿å­˜

**æµ‹è¯•ç”¨ä¾‹**ï¼š
1. é‡ç°cycle #1132çš„åœºæ™¯ â†’ AIåº”è¯¥èƒ½å‘ç°"æŒä»“SHORTä½†é¢„æµ‹UP"çš„çŸ›ç›¾
2. è¿ç»­2æ¬¡æ­¢æŸ â†’ AIåº”è¯¥æé†’é™ä½ä»“ä½
3. ç³»ç»Ÿé‡å¯ â†’ è®°å¿†ä»ç„¶å­˜åœ¨

---

### Sprint 2ï¼ˆç¬¬2å‘¨ï¼‰ï¼šæ•°æ®ç§¯ç´¯ä¸åˆ†ç±»

**ç›®æ ‡**ï¼šä¸ºAIè‡ªæˆ‘åˆ†æå‡†å¤‡ç»“æ„åŒ–æ•°æ®

#### 2.1 å¢å¼ºçš„æ•°æ®ç»“æ„

```go
// memory/enhanced.go

type EnhancedMemory struct {
    SimpleMemory  // åµŒå…¥Sprint 1çš„ç»“æ„

    // Episodic Memory: æŒ‰regimeåˆ†ç±»çš„å®Œæ•´äº¤æ˜“å†å²
    RegimePerformance map[string]*RegimeStats `json:"regime_performance"`

    // Signal Tracking: è¿½è¸ªæ¯ä¸ªä¿¡å·çš„æ•ˆæœ
    SignalTracking map[string]*SignalStats `json:"signal_tracking"`

    // Market Anomalies: ç‰¹æ®Šäº‹ä»¶è®°å½•
    MarketAnomalies []AnomalyEvent `json:"market_anomalies"`
}

type RegimeStats struct {
    Trades []TradeEntry `json:"trades"`

    // æŒ‰stageç»†åˆ†
    ByStage map[string]*StageStats `json:"by_stage"`
}

type StageStats struct {
    Entries      []TradeEntry `json:"entries"`
    WinCount     int          `json:"win_count"`
    LossCount    int          `json:"loss_count"`
    TotalReturn  float64      `json:"total_return"`
}

type SignalStats struct {
    Signal      string       `json:"signal"`
    Occurrences []TradeEntry `json:"occurrences"`

    // å•ç‹¬å‡ºç° vs ç»„åˆå‡ºç°
    AloneWinRate      float64 `json:"alone_win_rate"`
    CombinedWinRate   float64 `json:"combined_win_rate"`

    // ä¿¡å·æˆç†Ÿåº¦åˆ†æ
    MaturityAnalysis map[int]*MaturityStats `json:"maturity_analysis"`
}

type MaturityStats struct {
    Maturity    int     `json:"maturity"`  // ä¿¡å·å‡ºç°å‡ ä¸ªå‘¨æœŸ
    WinRate     float64 `json:"win_rate"`
    SampleSize  int     `json:"sample_size"`
}

type AnomalyEvent struct {
    EventID     string    `json:"event_id"`
    Timestamp   time.Time `json:"timestamp"`
    Type        string    `json:"type"`  // flash_crash/surge/black_swan
    Description string    `json:"description"`
    MyResponse  string    `json:"my_response"`
    Outcome     string    `json:"outcome"`
    Lesson      string    `json:"lesson"`
}
```

#### 2.2 è‡ªåŠ¨åˆ†ç±»ä¸ç»Ÿè®¡

```go
// memory/stats.go

func (m *EnhancedMemory) AddTrade(entry TradeEntry) {
    // 1. æ·»åŠ åˆ°recent tradesï¼ˆSprint 1é€»è¾‘ï¼‰
    m.SimpleMemory.addTrade(entry)

    // 2. æŒ‰regimeåˆ†ç±»
    regime := entry.MarketRegime
    if m.RegimePerformance[regime] == nil {
        m.RegimePerformance[regime] = &RegimeStats{
            Trades:  []TradeEntry{},
            ByStage: make(map[string]*StageStats),
        }
    }

    regimeStats := m.RegimePerformance[regime]
    regimeStats.Trades = append(regimeStats.Trades, entry)

    // 3. æŒ‰stageç»†åˆ†
    stage := entry.RegimeStage
    if regimeStats.ByStage[stage] == nil {
        regimeStats.ByStage[stage] = &StageStats{
            Entries: []TradeEntry{},
        }
    }

    stageStats := regimeStats.ByStage[stage]
    stageStats.Entries = append(stageStats.Entries, entry)

    if entry.Result == "win" {
        stageStats.WinCount++
    } else if entry.Result == "loss" {
        stageStats.LossCount++
    }
    stageStats.TotalReturn += entry.ReturnPct

    // 4. è¿½è¸ªä¿¡å·æ•ˆæœ
    for _, signal := range entry.Signals {
        if m.SignalTracking[signal] == nil {
            m.SignalTracking[signal] = &SignalStats{
                Signal:           signal,
                Occurrences:      []TradeEntry{},
                MaturityAnalysis: make(map[int]*MaturityStats),
            }
        }

        signalStats := m.SignalTracking[signal]
        signalStats.Occurrences = append(signalStats.Occurrences, entry)

        // ä¿¡å·æˆç†Ÿåº¦è¿½è¸ªï¼ˆå‡è®¾entryä¸­æœ‰SignalMaturityå­—æ®µï¼‰
        maturity := entry.SignalMaturity
        if signalStats.MaturityAnalysis[maturity] == nil {
            signalStats.MaturityAnalysis[maturity] = &MaturityStats{
                Maturity: maturity,
            }
        }

        matStats := signalStats.MaturityAnalysis[maturity]
        matStats.SampleSize++
        if entry.Result == "win" {
            matStats.WinRate = (matStats.WinRate*float64(matStats.SampleSize-1) + 1.0) / float64(matStats.SampleSize)
        } else {
            matStats.WinRate = (matStats.WinRate * float64(matStats.SampleSize-1)) / float64(matStats.SampleSize)
        }
    }

    // 5. æ£€æµ‹å¸‚åœºå¼‚å¸¸
    if isAnomaly(entry) {
        anomaly := AnomalyEvent{
            EventID:     fmt.Sprintf("anomaly_%d", m.TotalTrades),
            Timestamp:   entry.Timestamp,
            Type:        detectAnomalyType(entry),
            Description: entry.Reasoning,
            MyResponse:  entry.Action,
            Outcome:     entry.Result,
            Lesson:      "", // ç”±AIåœ¨åˆ†ææ—¶å¡«å†™
        }
        m.MarketAnomalies = append(m.MarketAnomalies, anomaly)
    }
}

// æ£€æµ‹å¼‚å¸¸äº‹ä»¶
func isAnomaly(entry TradeEntry) bool {
    // å•ç¬”äºæŸ > 3%
    if entry.ReturnPct < -3.0 {
        return true
    }

    // TODO: æ·»åŠ æ›´å¤šå¼‚å¸¸æ£€æµ‹é€»è¾‘
    // - ä»·æ ¼å•å°æ—¶å˜åŒ– > 5%
    // - æˆäº¤é‡å¼‚å¸¸æ”¾å¤§ï¼ˆ>3å€å‡å€¼ï¼‰

    return false
}
```

#### 2.3 Regime Stageåˆ¤æ–­å®ç°

```go
// decision/regime_stage.go

func DetermineRegimeStage(
    regime string,
    regimeDuration time.Duration,
    marketData *market.Data,
) string {
    timeScore := calculateTimeBasedStage(regime, regimeDuration)
    featureScore := calculateFeatureBasedStage(regime, marketData)

    finalScore := timeScore*0.7 + featureScore*0.3

    if finalScore < 0.33 {
        return "early"
    } else if finalScore < 0.67 {
        return "mid"
    }
    return "late"
}

func calculateTimeBasedStage(regime string, duration time.Duration) float64 {
    timelines := map[string]struct {
        EarlyMin, MidMin, LateMin time.Duration
    }{
        "accumulation": {0, 20 * time.Minute, 40 * time.Minute},
        "markup":       {0, 15 * time.Minute, 30 * time.Minute},
        "distribution": {0, 20 * time.Minute, 40 * time.Minute},
        "markdown":     {0, 10 * time.Minute, 25 * time.Minute},
    }

    timeline := timelines[regime]
    minutes := duration.Minutes()

    if minutes < timeline.EarlyMin.Minutes() {
        return 0.0
    } else if minutes < timeline.MidMin.Minutes() {
        // early â†’ mid: 0.0 â†’ 0.5
        progress := (minutes - timeline.EarlyMin.Minutes()) / (timeline.MidMin.Minutes() - timeline.EarlyMin.Minutes())
        return progress * 0.5
    } else if minutes < timeline.LateMin.Minutes() {
        // mid â†’ late: 0.5 â†’ 1.0
        progress := (minutes - timeline.MidMin.Minutes()) / (timeline.LateMin.Minutes() - timeline.MidMin.Minutes())
        return 0.5 + progress*0.5
    }
    return 1.0
}

func calculateFeatureBasedStage(regime string, data *market.Data) float64 {
    score := 0.5 // é»˜è®¤ä¸­æ€§

    // ç‰¹å¾1ï¼šä»·æ ¼åŠ¨é‡ï¼ˆMACDæ–œç‡ï¼‰
    if len(data.LongerTermContext.MACDValues) >= 3 {
        recent := data.LongerTermContext.MACDValues[len(data.LongerTermContext.MACDValues)-3:]
        slope := (recent[2] - recent[0]) / 2.0

        if regime == "accumulation" || regime == "markup" {
            if slope > 0 {
                score += 0.2 // åŠ¨é‡å¢å¼º = è¶‹åŠ¿æˆç†Ÿ
            } else {
                score -= 0.1 // åŠ¨é‡å‡å¼± = è¶‹åŠ¿ç–²æƒ«
            }
        }
    }

    // ç‰¹å¾2ï¼šæˆäº¤é‡
    volRatio := data.LongerTermContext.CurrentVolume / data.LongerTermContext.AverageVolume
    if volRatio > 1.5 {
        score += 0.2 // æˆäº¤é‡æ”¾å¤§ = mid stageç‰¹å¾
    } else if volRatio < 0.8 {
        score -= 0.2 // æˆäº¤é‡èç¼© = late stageç‰¹å¾
    }

    // ç‰¹å¾3ï¼šæ³¢åŠ¨ç‡
    atrRatio := data.LongerTermContext.ATR3 / data.LongerTermContext.ATR14
    if atrRatio > 1.2 {
        score += 0.1 // æ³¢åŠ¨ç‡å¢åŠ  = early/mid
    }

    return clamp(score, 0.0, 1.0)
}

func clamp(value, min, max float64) float64 {
    if value < min {
        return min
    } else if value > max {
        return max
    }
    return value
}
```

#### 2.4 Sprint 2æ•ˆæœéªŒè¯

**é¢„æœŸæ•ˆæœ**ï¼š
- âœ… äº¤æ˜“è‡ªåŠ¨æŒ‰regime/stageåˆ†ç±»
- âœ… ä¿¡å·æ•ˆæœè‡ªåŠ¨ç»Ÿè®¡ï¼ˆå•ç‹¬ vs ç»„åˆï¼Œæˆç†Ÿåº¦åˆ†æï¼‰
- âœ… å¸‚åœºå¼‚å¸¸äº‹ä»¶è‡ªåŠ¨è®°å½•
- âœ… æ•°æ®ç»“æ„ready for AIåˆ†æ

**æµ‹è¯•**ï¼š
- è¿è¡Œ50ç¬”äº¤æ˜“åï¼Œæ£€æŸ¥`RegimePerformance`æ˜¯å¦æ­£ç¡®åˆ†ç±»
- æ£€æŸ¥`SignalTracking`ä¸­"MACDé‡‘å‰"çš„ç»Ÿè®¡æ•°æ®
- äººå·¥è§¦å‘ä¸€æ¬¡å¼‚å¸¸ï¼ˆå¦‚å•ç¬”-3.5%äºæŸï¼‰ â†’ æ£€æŸ¥æ˜¯å¦è®°å½•åˆ°`MarketAnomalies`

---

### Sprint 3ï¼ˆç¬¬3-4å‘¨ï¼‰ï¼šAIè‡ªæˆ‘åˆ†æä¸é•¿æœŸè®°å¿†

**ç›®æ ‡**ï¼š100ç¬”äº¤æ˜“åï¼ŒAIç”Ÿæˆinsightsï¼Œå½¢æˆ"äº¤æ˜“äººæ ¼"

#### 3.1 Semantic Memoryç»“æ„

```go
// memory/semantic.go

type SemanticMemory struct {
    Version       int       `json:"version"`
    GeneratedAt   time.Time `json:"generated_at"`
    BasedOnTrades int       `json:"based_on_trades"`
    NextUpdateAt  int       `json:"next_update_at"`

    // AIæç‚¼çš„insights
    RegimeInsights      map[string]*RegimeInsight `json:"regime_insights"`
    SignalEffectiveness map[string]*SignalInsight `json:"signal_effectiveness"`
    RepeatedMistakes    []string                   `json:"repeated_mistakes"`
    ActionablePrinciples []string                  `json:"actionable_principles"`

    // è¿›åŒ–è¿½è¸ª
    Evolution *InsightEvolution `json:"evolution,omitempty"`
}

type RegimeInsight struct {
    Regime               string  `json:"regime"`
    OverallPerformance   string  `json:"overall_performance"`  // "Good (65% win rate)"
    OverallWinRate       float64 `json:"overall_win_rate"`

    BestStage            string  `json:"best_stage"`
    WorstStage           string  `json:"worst_stage"`

    ByStage              map[string]*StageInsight `json:"by_stage"`

    AIAnalysis           string  `json:"ai_analysis"`
    TimingRecommendation string  `json:"timing_recommendation"`
}

type StageInsight struct {
    Stage       string  `json:"stage"`
    WinRate     float64 `json:"win_rate"`
    AvgReturn   float64 `json:"avg_return"`
    SampleSize  int     `json:"sample_size"`
    Confidence  string  `json:"confidence"`  // low/medium/high
}

type SignalInsight struct {
    Signal              string                  `json:"signal"`
    OverallWinRate      float64                 `json:"overall_win_rate"`
    ByMaturity          map[string]*MaturityInsight `json:"by_maturity"`
    BestCombinations    []SignalCombination     `json:"best_combinations"`
    AIInsight           string                  `json:"ai_insight"`
}

type MaturityInsight struct {
    Description string  `json:"description"`  // "immediate"/"confirmed_1_cycle"/"confirmed_2_cycles"
    WinRate     float64 `json:"win_rate"`
    SampleSize  int     `json:"sample_size"`
}

type SignalCombination struct {
    Signals    []string `json:"signals"`
    WinRate    float64  `json:"win_rate"`
    SampleSize int      `json:"sample_size"`
}

type InsightEvolution struct {
    Validated []string                   `json:"validated"`
    Corrected []InsightCorrection        `json:"corrected"`
    NewPatterns []string                 `json:"new_patterns"`
}

type InsightCorrection struct {
    OldPrinciple string `json:"old_principle"`
    NewPrinciple string `json:"new_principle"`
    Reason       string `json:"reason"`
}
```

#### 3.2 AIåˆ†ææœåŠ¡

```go
// memory/analyzer.go

type Analyzer struct {
    mcpClient *mcp.Client
}

func NewAnalyzer(client *mcp.Client) *Analyzer {
    return &Analyzer{mcpClient: client}
}

// GenerateInsights ç”ŸæˆAI insightsï¼ˆ100ç¬”äº¤æ˜“åé¦–æ¬¡è°ƒç”¨ï¼‰
func (a *Analyzer) GenerateInsights(memory *EnhancedMemory) (*SemanticMemory, error) {
    // 1. å‡†å¤‡åˆ†ææ•°æ®
    analysisData := a.prepareAnalysisData(memory)

    // 2. æ„å»ºprompt
    systemPrompt := `ä½ æ˜¯ä¸€ä¸ªé‡åŒ–äº¤æ˜“å‘˜ï¼Œæ­£åœ¨åˆ†æè‡ªå·±çš„äº¤æ˜“è®°å½•ï¼Œè¿›è¡Œæ·±åº¦è‡ªæˆ‘åæ€ã€‚

è¯·åŸºäºæ•°æ®å›ç­”ä»¥ä¸‹é—®é¢˜ï¼š
1. ä½ åœ¨å“ªä¸ªmarket regimeè¡¨ç°æœ€å¥½/æœ€å·®ï¼Ÿæ¯ä¸ªregimeçš„early/mid/lateé˜¶æ®µèƒœç‡å¦‚ä½•ï¼Ÿ
2. å“ªäº›ä¿¡å·ç»„åˆæœ€æœ‰æ•ˆï¼Ÿä¿¡å·æˆç†Ÿåº¦ï¼ˆåˆšå‡ºç° vs ç¡®è®¤1-2ä¸ªå‘¨æœŸï¼‰å¯¹èƒœç‡æœ‰ä½•å½±å“ï¼Ÿ
3. ä½ çŠ¯è¿‡å“ªäº›é‡å¤æ€§é”™è¯¯ï¼Ÿï¼ˆè‡³å°‘å‘ç”Ÿ3æ¬¡ä»¥ä¸Šçš„äºæŸæ¨¡å¼ï¼‰
4. åŸºäºæ•°æ®ï¼Œç»™å‡º3-5æ¡å¯æ‰§è¡Œçš„äº¤æ˜“åŸåˆ™

è¾“å‡ºJSONæ ¼å¼ï¼š
{
  "regime_insights": {
    "accumulation": {
      "overall_performance": "Good (win rate 65%)",
      "overall_win_rate": 0.65,
      "best_stage": "mid",
      "worst_stage": "early",
      "by_stage": {
        "early": {"win_rate": 0.38, "avg_return": -0.5, "sample_size": 8},
        "mid": {"win_rate": 0.75, "avg_return": 1.8, "sample_size": 12},
        "late": {"win_rate": 0.60, "avg_return": 1.1, "sample_size": 5}
      },
      "ai_analysis": "æˆ‘åœ¨accumulationä¸­æœŸè¡¨ç°æœ€å¥½ï¼ˆ75%ï¼‰ï¼Œæ—©æœŸèƒœç‡å¾ˆä½ï¼ˆ38%ï¼‰ã€‚åŸå› ï¼šæ—©æœŸä¿¡å·ä¸æˆç†Ÿï¼Œä»·æ ¼ç»å¸¸ç»§ç»­ä¸‹æ¢ã€‚",
      "timing_recommendation": "æœ€ä½³å…¥åœºæ—¶æœºï¼šregimeæŒç»­20-40åˆ†é’Ÿï¼ˆmid stageï¼‰+ ä¿¡å·ç¡®è®¤2ä¸ªå‘¨æœŸ"
    }
  },
  "signal_effectiveness": {
    "MACDé‡‘å‰": {
      "overall_win_rate": 0.67,
      "by_maturity": {
        "immediate": {"win_rate": 0.47, "sample_size": 15},
        "confirmed_1_cycle": {"win_rate": 0.71, "sample_size": 12},
        "confirmed_2_cycles": {"win_rate": 0.78, "sample_size": 9}
      },
      "best_combinations": [
        {"signals": ["MACDé‡‘å‰", "OIæ¿€å¢"], "win_rate": 0.82, "sample_size": 11},
        {"signals": ["MACDé‡‘å‰", "è´Ÿèµ„é‡‘è´¹ç‡"], "win_rate": 0.88, "sample_size": 8}
      ],
      "ai_insight": "MACDé‡‘å‰ç­‰å¾…1-2ä¸ªå‘¨æœŸç¡®è®¤ï¼Œèƒœç‡æ˜¾è‘—æå‡ï¼ˆ47%â†’71%â†’78%ï¼‰ã€‚é…åˆOIæ¿€å¢æˆ–è´Ÿè´¹ç‡æ—¶ï¼Œèƒœç‡è¾¾80%+"
    }
  },
  "repeated_mistakes": [
    "åœ¨accumulationæ—©æœŸè¿‡æ—©å¼€ä»“ï¼ˆ8æ¬¡ä¸­5æ¬¡äºæŸï¼Œå¹³å‡-1.2%ï¼‰",
    "åœ¨distributionè¿½é«˜ï¼ˆ7æ¬¡å…¨éƒ¨è¢«å¥—ï¼Œå¹³å‡-2.1%ï¼‰",
    "è¿ç»­æ­¢æŸåæœªé™ä½ä»“ä½ï¼ˆå¯¼è‡´å›æ’¤æ‰©å¤§ï¼‰"
  ],
  "actionable_principles": [
    "accumulation early: è§‚æœ›ä¸ºä¸»ï¼Œæˆ–ç­‰ä¿¡å·ç¡®è®¤2ä¸ªå‘¨æœŸ",
    "accumulation mid: æœ€ä½³å…¥åœºçª—å£ï¼Œä¿¡å·ç¡®è®¤1ä¸ªå‘¨æœŸå³å¯å…¥åœº",
    "markup early: æˆ‘çš„ä¼˜åŠ¿æ—¶æ®µï¼Œæœæ–­å…¥åœºï¼ˆç”šè‡³å¯ä»¥ä¿¡å·åˆšå‡ºç°å°±å…¥åœºï¼‰",
    "distribution: ä¸è½»æ˜“åšå¤šï¼Œé™¤éæœ‰æ˜ç¡®åè½¬ä¿¡å·",
    "ä¿¡å·ç»„åˆ: MACDé‡‘å‰+OIæ¿€å¢+è´Ÿè´¹ç‡ = é«˜èƒœç‡ä¿¡å·",
    "é£æ§: è¿ç»­2æ¬¡æ­¢æŸåï¼Œä»“ä½é™è‡³30%ï¼Œä¿¡å·è¦æ±‚æå‡è‡³4æ˜Ÿä»¥ä¸Š"
  ]
}`

    userPrompt := fmt.Sprintf(`## äº¤æ˜“æ•°æ®æ‘˜è¦

æ€»äº¤æ˜“æ•°: %d
æ•´ä½“èƒœç‡: %.1f%%
å¹³å‡æ”¶ç›Š: %.2f%%

## Regimeè¡¨ç°

%s

## ä¿¡å·æ•ˆæœç»Ÿè®¡

%s

## æœ€è¿‘å¼‚å¸¸äº‹ä»¶

%s

è¯·åˆ†æä»¥ä¸Šæ•°æ®å¹¶è¾“å‡ºJSONã€‚`,
        memory.TotalTrades,
        calculateOverallWinRate(memory)*100,
        calculateAvgReturn(memory),
        formatRegimeStats(memory.RegimePerformance),
        formatSignalStats(memory.SignalTracking),
        formatAnomalies(memory.MarketAnomalies),
    )

    // 3. è°ƒç”¨AI
    response, err := a.mcpClient.CallWithMessages(systemPrompt, userPrompt)
    if err != nil {
        return nil, fmt.Errorf("AIè°ƒç”¨å¤±è´¥: %w", err)
    }

    // 4. è§£æå“åº”
    jsonData := extractJSON(response)
    if jsonData == "" {
        return nil, fmt.Errorf("æ— æ³•ä»å“åº”ä¸­æå–JSON")
    }

    var insights SemanticMemory
    if err := json.Unmarshal([]byte(jsonData), &insights); err != nil {
        return nil, fmt.Errorf("JSONè§£æå¤±è´¥: %w", err)
    }

    // 5. å¡«å……å…ƒæ•°æ®
    insights.Version = 1
    insights.GeneratedAt = time.Now()
    insights.BasedOnTrades = memory.TotalTrades
    insights.NextUpdateAt = memory.TotalTrades + 50

    return &insights, nil
}

// UpdateInsights æ›´æ–°insightsï¼ˆæ¯50ç¬”äº¤æ˜“åï¼‰
func (a *Analyzer) UpdateInsights(
    memory *EnhancedMemory,
    oldInsights *SemanticMemory,
) (*SemanticMemory, error) {
    // 1. ç”Ÿæˆæ–°çš„insights
    newInsights, err := a.GenerateInsights(memory)
    if err != nil {
        return nil, err
    }

    // 2. å¯¹æ¯”æ–°æ—§insights
    evolution := a.compareInsights(oldInsights, newInsights, memory)
    newInsights.Evolution = evolution
    newInsights.Version = oldInsights.Version + 1

    return newInsights, nil
}

// compareInsights å¯¹æ¯”æ–°æ—§insightsï¼Œç”Ÿæˆè¿›åŒ–è¿½è¸ª
func (a *Analyzer) compareInsights(
    old, new *SemanticMemory,
    memory *EnhancedMemory,
) *InsightEvolution {
    evolution := &InsightEvolution{
        Validated:   []string{},
        Corrected:   []InsightCorrection{},
        NewPatterns: []string{},
    }

    // éªŒè¯æ—§åŸåˆ™æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
    for _, oldPrinciple := range old.ActionablePrinciples {
        isStillValid := a.validatePrinciple(oldPrinciple, memory)
        if isStillValid {
            evolution.Validated = append(evolution.Validated, oldPrinciple)
        }
    }

    // æ£€æµ‹ä¿®æ­£
    for i, oldPrinciple := range old.ActionablePrinciples {
        if i < len(new.ActionablePrinciples) {
            newPrinciple := new.ActionablePrinciples[i]
            if oldPrinciple != newPrinciple {
                evolution.Corrected = append(evolution.Corrected, InsightCorrection{
                    OldPrinciple: oldPrinciple,
                    NewPrinciple: newPrinciple,
                    Reason:       "åŸºäºæœ€æ–°æ•°æ®çš„è°ƒæ•´",
                })
            }
        }
    }

    // æ£€æµ‹æ–°æ¨¡å¼ï¼ˆæ–°åŸåˆ™ï¼‰
    for _, newPrinciple := range new.ActionablePrinciples {
        isNew := true
        for _, oldPrinciple := range old.ActionablePrinciples {
            if newPrinciple == oldPrinciple {
                isNew = false
                break
            }
        }
        if isNew {
            evolution.NewPatterns = append(evolution.NewPatterns, newPrinciple)
        }
    }

    return evolution
}

func (a *Analyzer) validatePrinciple(principle string, memory *EnhancedMemory) bool {
    // TODO: å®ç°éªŒè¯é€»è¾‘
    // ä¾‹å¦‚ï¼š"accumulation earlyè§‚æœ›" â†’ æ£€æŸ¥æœ€è¿‘20ç¬”éµå®ˆæ­¤åŸåˆ™çš„äº¤æ˜“ï¼Œèƒœç‡æ˜¯å¦æå‡
    return true
}
```

#### 3.3 å†³ç­–æ—¶æ³¨å…¥é•¿æœŸè®°å¿†

```go
// decision/prompt_builder.go

func BuildPromptWithMemory(
    memory *EnhancedMemory,
    marketData *market.Data,
    intelligence *MarketIntelligence,
) (systemPrompt, userPrompt string) {
    systemPrompt = `ä½ æ˜¯ä¸€ä¸ªæœ‰è®°å¿†çš„AI traderï¼Œèƒ½å¤Ÿä»å†å²ç»éªŒä¸­å­¦ä¹ ã€‚
ä½ çš„å†³ç­–åº”è¯¥åŸºäºï¼š
1. ä½ çš„å†å²è¡¨ç°åˆ†æï¼ˆå“ªäº›regime/stageä½ è¡¨ç°å¥½ï¼Œå“ªäº›ä¸å¥½ï¼‰
2. ä½ æ€»ç»“çš„äº¤æ˜“åŸåˆ™ï¼ˆå·²éªŒè¯çš„è§„å¾‹ï¼‰
3. å½“å‰å¸‚åœºæ•°æ®å’ŒæŠ€æœ¯æŒ‡æ ‡
4. ä½ æœ€è¿‘çš„å†³ç­–ï¼ˆä¿æŒä¸€è‡´æ€§ï¼‰`

    userPrompt = ""

    // 1. é•¿æœŸè®°å¿†ï¼ˆSemantic Memoryï¼‰
    if memory.AIInsights != nil {
        insights := memory.AIInsights

        userPrompt += "## ğŸ“š ä½ çš„ç»éªŒï¼ˆåŸºäºè¿‡å»" + strconv.Itoa(insights.BasedOnTrades) + "ç¬”äº¤æ˜“ï¼‰\n\n"

        // Regime insights
        currentRegime := intelligence.MarketPhase
        if regimeInsight, exists := insights.RegimeInsights[currentRegime]; exists {
            userPrompt += fmt.Sprintf("### %sé˜¶æ®µè¡¨ç°\n", currentRegime)
            userPrompt += fmt.Sprintf("- æ•´ä½“èƒœç‡: %.1f%%\n", regimeInsight.OverallWinRate*100)
            userPrompt += fmt.Sprintf("- æœ€ä½³stage: %s\n", regimeInsight.BestStage)
            userPrompt += fmt.Sprintf("- æœ€å·®stage: %s\n", regimeInsight.WorstStage)
            userPrompt += fmt.Sprintf("- AIåˆ†æ: %s\n", regimeInsight.AIAnalysis)
            userPrompt += fmt.Sprintf("- æ—¶æœºå»ºè®®: %s\n\n", regimeInsight.TimingRecommendation)
        }

        // Actionable principles
        userPrompt += "### ğŸ’¡ ä½ çš„äº¤æ˜“åŸåˆ™\n"
        for i, principle := range insights.ActionablePrinciples {
            userPrompt += fmt.Sprintf("%d. %s\n", i+1, principle)
        }
        userPrompt += "\n"

        // Evolutionï¼ˆå¦‚æœæœ‰ï¼‰
        if insights.Evolution != nil {
            if len(insights.Evolution.Validated) > 0 {
                userPrompt += "### âœ… å·²éªŒè¯çš„ç­–ç•¥\n"
                for _, v := range insights.Evolution.Validated {
                    userPrompt += fmt.Sprintf("- %s\n", v)
                }
                userPrompt += "\n"
            }

            if len(insights.Evolution.NewPatterns) > 0 {
                userPrompt += "### ğŸ†• æ–°å‘ç°çš„æ¨¡å¼\n"
                for _, p := range insights.Evolution.NewPatterns {
                    userPrompt += fmt.Sprintf("- %s\n", p)
                }
                userPrompt += "\n"
            }
        }
    }

    // 2. çŸ­æœŸè®°å¿†ï¼ˆWorking Memoryï¼‰
    userPrompt += memory.GetContextPrompt() + "\n"

    // 3. å½“å‰å¸‚åœºçŠ¶æ€
    regimeStage := DetermineRegimeStage(
        intelligence.MarketPhase,
        time.Since(intelligence.RegimeStartTime),
        marketData,
    )

    userPrompt += "## ğŸ“Š å½“å‰å¸‚åœºçŠ¶æ€\n\n"
    userPrompt += fmt.Sprintf("Market Phase: %s (å·²æŒç»­%dåˆ†é’Ÿï¼Œå¤„äº%sé˜¶æ®µ)\n",
        intelligence.MarketPhase,
        int(time.Since(intelligence.RegimeStartTime).Minutes()),
        regimeStage,
    )
    userPrompt += formatMarketData(marketData) + "\n"

    // 4. å†³ç­–æŒ‡å¼•
    userPrompt += `## ğŸ¤” ä½ çš„ä»»åŠ¡

åŸºäºä½ çš„å†å²ç»éªŒå’Œå½“å‰æ•°æ®ï¼Œå†³å®šæ˜¯å¦å…¥åœº/æŒæœ‰/å¹³ä»“ã€‚

ç‰¹åˆ«æ³¨æ„ï¼š
1. å½“å‰å¤„äºä»€ä¹ˆregime stageï¼Ÿä½ åœ¨è¿™ä¸ªstageçš„å†å²èƒœç‡å¦‚ä½•ï¼Ÿ
2. å½“å‰ä¿¡å·çš„æˆç†Ÿåº¦å¦‚ä½•ï¼Ÿä½ çš„ç»éªŒä¸­è¿™ç§æˆç†Ÿåº¦çš„èƒœç‡å¦‚ä½•ï¼Ÿ
3. æ˜¯å¦è§¦çŠ¯äº†ä½ æ€»ç»“çš„"é‡å¤æ€§é”™è¯¯"ï¼Ÿ
4. ä½ çš„å†³ç­–æ˜¯å¦ä¸ä½ çš„äº¤æ˜“åŸåˆ™ä¸€è‡´ï¼Ÿ

è¾“å‡ºJSONæ ¼å¼ï¼š
[
  {
    "symbol": "BTCUSDT",
    "action": "open/close/hold",
    "reasoning": "è¯¦ç»†æ¨ç†ï¼ˆå¿…é¡»å¼•ç”¨ä½ çš„å†å²ç»éªŒï¼‰"
  }
]`

    return systemPrompt, userPrompt
}
```

#### 3.4 è‡ªé€‚åº”æ›´æ–°è§¦å‘

```go
// memory/update_trigger.go

type UpdateTrigger struct {
    lastUpdateAt    time.Time
    lastTotalTrades int
}

func NewUpdateTrigger() *UpdateTrigger {
    return &UpdateTrigger{}
}

func (t *UpdateTrigger) Check(memory *EnhancedMemory) (bool, string) {
    // è§„åˆ™1ï¼šé¦–æ¬¡åˆ†æï¼ˆ100ç¬”ï¼‰
    if memory.TotalTrades >= 100 && memory.AIInsights == nil {
        return true, "first_analysis"
    }

    // è§„åˆ™2ï¼šå®šæœŸæ›´æ–°ï¼ˆæ¯50ç¬”ï¼‰
    if memory.AIInsights != nil {
        tradesSinceUpdate := memory.TotalTrades - t.lastTotalTrades
        if tradesSinceUpdate >= 50 {
            return true, "scheduled_update"
        }
    }

    // è§„åˆ™3ï¼šæ€§èƒ½çªå˜
    if memory.TotalTrades >= 20 && memory.AIInsights != nil {
        recentWinRate := calculateRecentWinRate(memory, 20)
        historicalWinRate := memory.AIInsights.OverallWinRate

        if math.Abs(recentWinRate-historicalWinRate) > 0.2 {
            return true, fmt.Sprintf("performance_anomaly: recent=%.1f%% vs historical=%.1f%%",
                recentWinRate*100, historicalWinRate*100)
        }
    }

    // è§„åˆ™4ï¼šæ–°æ¨¡å¼æ£€æµ‹
    if hasNewPattern(memory.GetRecentTrades(20)) {
        return true, "new_pattern_detected"
    }

    return false, ""
}

func (t *UpdateTrigger) MarkUpdated(totalTrades int) {
    t.lastUpdateAt = time.Now()
    t.lastTotalTrades = totalTrades
}

func calculateRecentWinRate(memory *EnhancedMemory, n int) float64 {
    trades := memory.GetRecentTrades(n)
    wins := 0
    for _, trade := range trades {
        if trade.Result == "win" {
            wins++
        }
    }
    return float64(wins) / float64(len(trades))
}

func hasNewPattern(trades []TradeEntry) bool {
    // æ£€æµ‹è¿ç»­5æ¬¡ç›¸åŒä¿¡å·ç»„åˆ
    signalGroups := make(map[string]int)

    for _, trade := range trades {
        key := strings.Join(trade.Signals, "+")
        signalGroups[key]++
    }

    for _, count := range signalGroups {
        if count >= 5 {
            // TODO: æ£€æŸ¥å†å²æ€»æ¬¡æ•°ï¼Œå¦‚æœ<10æ¬¡è®¤ä¸ºæ˜¯æ–°æ¨¡å¼
            return true
        }
    }

    return false
}
```

#### 3.5 Sprint 3æ•ˆæœéªŒè¯

**é¢„æœŸæ•ˆæœ**ï¼š
- âœ… 100ç¬”äº¤æ˜“åï¼ŒAIè‡ªåŠ¨ç”Ÿæˆinsights
- âœ… AIèƒ½åŸºäºå†å²ç»éªŒåšå†³ç­–ï¼ˆå¦‚"æˆ‘åœ¨accumulation midè¡¨ç°æœ€å¥½ï¼Œç°åœ¨æ­£å¥½æ˜¯è¿™ä¸ªé˜¶æ®µï¼Œå¯ä»¥å…¥åœº"ï¼‰
- âœ… æ¯50ç¬”è‡ªåŠ¨æ›´æ–°insightsï¼Œèƒ½æ£€æµ‹ç­–ç•¥å¤±æ•ˆ
- âœ… å½¢æˆç¨³å®šçš„"äº¤æ˜“äººæ ¼"

**æµ‹è¯•**ï¼š
1. æ‰‹åŠ¨è§¦å‘100ç¬”äº¤æ˜“ â†’ æ£€æŸ¥`AIInsights`æ˜¯å¦ç”Ÿæˆ
2. æ£€æŸ¥AIå†³ç­–çš„reasoningä¸­æ˜¯å¦å¼•ç”¨äº†å†å²ç»éªŒ
3. äººå·¥ä¿®æ”¹æœ€è¿‘20ç¬”çš„ç»“æœä¸ºå…¨äºæŸ â†’ æ£€æŸ¥æ˜¯å¦è§¦å‘"æ€§èƒ½çªå˜"æ›´æ–°

---

## ğŸ“Š ç›‘æ§æŒ‡æ ‡ï¼ˆSprint 4 å¯é€‰ï¼‰

### KPI Dashboard

```go
type MemoryMetrics struct {
    // å­¦ä¹ æ•ˆç‡
    LearningCurve     []float64 `json:"learning_curve"`      // æ¯20ç¬”çš„èƒœç‡
    InsightImpact     float64   `json:"insight_impact"`       // insightsæ›´æ–°å‰åçš„èƒœç‡æå‡

    // è®°å¿†è´¨é‡
    DecisionCoherence float64   `json:"decision_coherence"`   // ç›¸ä¼¼æƒ…å†µä¸‹å†³ç­–çš„ä¸€è‡´æ€§
    InsightAccuracy   float64   `json:"insight_accuracy"`     // é¢„æµ‹vså®é™…çš„å‡†ç¡®ç‡

    // é€‚åº”èƒ½åŠ›
    RegimeAdaptation  map[string]float64 `json:"regime_adaptation"` // æ¯ä¸ªregimeåˆ‡æ¢åçš„é€‚åº”é€Ÿåº¦
    NoveltyHandling   float64   `json:"novelty_handling"`     // å¤„ç†æ–°æƒ…å†µçš„èƒ½åŠ›

    // å‡è®¾éªŒè¯
    ValidatedCount    int       `json:"validated_count"`
    RejectedCount     int       `json:"rejected_count"`
    ActiveHypotheses  []Hypothesis `json:"active_hypotheses"`
}

type Hypothesis struct {
    ID          string  `json:"id"`
    Statement   string  `json:"statement"`
    TestCount   int     `json:"test_count"`
    SuccessCount int    `json:"success_count"`
    Confidence  float64 `json:"confidence"`
    Status      string  `json:"status"`  // testing/validated/rejected
}
```

---

## â±ï¸ æ—¶é—´çº¿æ€»ç»“

| Sprint | æ—¶é—´ | ç›®æ ‡ | äº¤ä»˜ç‰© | ç«‹å³æ•ˆæœ |
|--------|------|------|--------|---------|
| Sprint 1 | ç¬¬1å‘¨ | è§£å†³"å¤±å¿†ç—‡" | SimpleMemory + çŸ­æœŸè®°å¿†æ³¨å…¥ | AIèƒ½è®°ä½æœ€è¿‘å†³ç­–ï¼Œé¿å…è‡ªç›¸çŸ›ç›¾ |
| Sprint 2 | ç¬¬2å‘¨ | æ•°æ®ç§¯ç´¯ä¸åˆ†ç±» | EnhancedMemory + è‡ªåŠ¨ç»Ÿè®¡ | æŒ‰regime/stage/signalåˆ†ç±»ï¼Œå¼‚å¸¸äº‹ä»¶è®°å½• |
| Sprint 3 | ç¬¬3-4å‘¨ | AIè‡ªæˆ‘åˆ†æ | SemanticMemory + AI insights | å½¢æˆ"äº¤æ˜“äººæ ¼"ï¼ŒåŸºäºç»éªŒå†³ç­– |
| Sprint 4 | ç¬¬5å‘¨+ | ç›‘æ§ä¸ä¼˜åŒ– | Metrics Dashboard + å‘é‡æ£€ç´¢ | é‡åŒ–è®°å¿†ç³»ç»Ÿæ•ˆæœï¼ŒæŒç»­ä¼˜åŒ– |

---

## ğŸ¯ æˆåŠŸæ ‡å‡†

### Sprint 1 éªŒæ”¶æ ‡å‡†
- [ ] ç³»ç»Ÿé‡å¯åï¼Œè®°å¿†ä»ç„¶å­˜åœ¨
- [ ] AIèƒ½çœ‹åˆ°æœ€è¿‘3æ¬¡å†³ç­–
- [ ] AIå†³ç­–reasoningä¸­æåˆ°"æˆ‘ä¸Šæ¬¡..."
- [ ] Cycle #1132ç±»å‹çš„çŸ›ç›¾ä¸å†å‘ç”Ÿ

### Sprint 2 éªŒæ”¶æ ‡å‡†
- [ ] äº¤æ˜“è‡ªåŠ¨åˆ†ç±»åˆ°æ­£ç¡®çš„regime/stage
- [ ] SignalTrackingç»Ÿè®¡å‡†ç¡®ï¼ˆæ‰‹å·¥éªŒè¯5ä¸ªä¿¡å·ï¼‰
- [ ] å¼‚å¸¸äº‹ä»¶è‡ªåŠ¨è®°å½•ï¼ˆè§¦å‘å•ç¬”-3%äºæŸæµ‹è¯•ï¼‰
- [ ] æ•°æ®ç»“æ„å®Œæ•´ï¼Œready for AIåˆ†æ

### Sprint 3 éªŒæ”¶æ ‡å‡†
- [ ] 100ç¬”äº¤æ˜“åï¼ŒAIInsightsè‡ªåŠ¨ç”Ÿæˆ
- [ ] AIå†³ç­–reasoningå¼•ç”¨å†å²ç»éªŒï¼ˆè‡³å°‘50%çš„å†³ç­–ï¼‰
- [ ] æ¯50ç¬”è‡ªåŠ¨æ›´æ–°insights
- [ ] æ€§èƒ½çªå˜è§¦å‘ç«‹å³æ›´æ–°
- [ ] Insight Evolutionæ­£ç¡®è¿½è¸ªéªŒè¯/ä¿®æ­£/æ–°æ¨¡å¼

### æ•´ä½“æ•ˆæœæ ‡å‡†ï¼ˆ1ä¸ªæœˆåï¼‰
- [ ] å†³ç­–ä¸€è‡´æ€§æå‡ï¼šDecisionCoherence > 0.8
- [ ] å­¦ä¹ æ•ˆæœå¯è§ï¼šæœ€è¿‘50ç¬”èƒœç‡ > å‰50ç¬”èƒœç‡
- [ ] ç»éªŒæœ‰æ•ˆæ€§ï¼šè‡³å°‘3æ¡actionable principlesè¢«éªŒè¯æœ‰æ•ˆ
- [ ] é€‚åº”èƒ½åŠ›ï¼šæ–°regimeå‰5ç¬”èƒœç‡ > 40%ï¼ˆä¸è‡³äºå®Œå…¨ä¸é€‚åº”ï¼‰

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0ï¼ˆæ•´åˆä¼˜åŒ–å»ºè®®ï¼‰
**æ›´æ–°æ—¥æœŸ**: 2025-11-13
**åŸºäº**: AI_PERSISTENT_MEMORY_DESIGN.md + AI_PERSISTENT_MEMORY_DESIGN_change.md
